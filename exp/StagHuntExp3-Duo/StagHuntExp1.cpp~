#include "includes.hpp"
#include "defparams.hpp"

namespace sferes
{
  using namespace nn;
  
  // ********** Main Class ***********
  SFERES_FITNESS(FitStagHunt, sferes::fit::Fitness)
  {
  public:
#ifdef MLP
		typedef Neuron<PfWSum<>, AfSigmoidNoBias<> > neuron_t;
		typedef Connection<float> connection_t;
		typedef Mlp< neuron_t, connection_t > nn_t;
#else
		typedef NN<Neuron<PfWSum<>, AfSigmoidNoBias<float> >, Connection<> > nn_t;
#endif

    template<typename Indiv>
      void eval(Indiv& ind) 
    {
			std::cout << "This experiment is supposed to use the eval_compet function !" << std::endl;
    }

		float felli(const std::vector<float>& xx)
		{
			Eigen::VectorXf x = Eigen::VectorXf::Zero(xx.size());
			for (size_t i = 0; i < xx.size(); ++i)
				x[i] = xx[i];
			Eigen::VectorXf v = Eigen::VectorXf::Zero(x.size());
			for (size_t i = 0; i < v.size(); ++i)
				v[i] = powf(1e6, i / (x.size() - 1.0f));
			return v.dot(x.cwise() * x);
		}
		    
    template<typename Indiv>
    	void eval_compet(Indiv& ind1, Indiv& ind2)
    {
#ifdef MLP
      nn_t nn1(Params::nn::nb_inputs, Params::nn::nb_hidden, Params::nn::nb_outputs);
      nn_t nn2(Params::nn::nb_inputs, Params::nn::nb_hidden, Params::nn::nb_outputs);
#else
			nn_t nn1, nn2;

			nn1.set_nb_inputs(Params::nn::nb_inputs + 1);
			nn1.set_nb_outputs(Params::nn::nb_outputs);
			nn1.full_connect(nn1.get_inputs(), nn1.get_outputs(), 1.0f);

			nn2.set_nb_inputs(Params::nn::nb_inputs + 1);
			nn2.set_nb_outputs(Params::nn::nb_outputs);
			nn2.full_connect(nn2.get_inputs(), nn2.get_outputs(), 1.0f);
#endif

      nn1.set_all_weights(ind1.data());
      nn2.set_all_weights(ind2.data());
      
#ifdef TEST
			ind1.fit().set_value(-felli(ind1.data()));
			ind2.fit().set_value(-felli(ind2.data()));
/*			std::vector<float> inputs1, inputs2;
			inputs1.resize(Params::nn::nb_inputs + 1);
			inputs2.resize(Params::nn::nb_inputs + 1);
			for(int i = 0; i < Params::nn::values_size(); ++i)
			{
				inputs1[i] = Params::nn::values(i);
				inputs2[i] = Params::nn::values(i);
			}
				
			inputs1[Params::nn::values_size()] = 1.0;
			inputs2[Params::nn::values_size()] = 1.0;
				
			nn1.init();
			nn2.init();
				
			nn1.step(inputs1);
			nn2.step(inputs2);
			
			std::vector<float> outf;
      const std::vector<float>& outf2 = nn1.get_outf();
      outf = outf2;
			
			float value = -(sqrt(pow(outf[0] - 0.5, 2)));

			ind1.fit().set_value(value);

      const std::vector<float>& outf3 = nn2.get_outf();
      outf = outf3;
			
			value = -(sqrt(pow(outf[0] - 1, 2)));
			ind2.fit().set_value(value);*/
#else

//    	vec_nn.push_back(nn1);
//    	vec_nn.push_back(nn2);

      typedef simu::FastsimMulti<Params> simu_t;

      using namespace fastsim;	

      // *** Main Loop *** 
//      int nb_victoires1 = 0, nb_victoires2 = 0;
      float moy_hares1 = 0, moy_sstags1 = 0, moy_bstags1 = 0;
      float moy_hares1_solo = 0, moy_sstags1_solo = 0, moy_bstags1_solo = 0;
      float moy_hares2 = 0, moy_sstags2 = 0, moy_bstags2 = 0;
      float moy_hares2_solo = 0, moy_sstags2_solo = 0, moy_bstags2_solo = 0;
      float fit_mov1 = 0, fit_mov2 = 0;
     	int food1 = 0, food2 = 0;
     	
     	max_big_stags = Params::simu::ratio_big_small * Params::simu::nb_big_stags;
     	max_small_stags = Params::simu::nb_big_stags - max_big_stags;
     	
    	this->set_mode(fit::mode::view);
    
      for (size_t j = 0; j < Params::simu::nb_trials; ++j)
      {
      	// init
	      simu_t simu;
	      init_simu(simu, nn1, nn2);

		    for (size_t i = 0; i < Params::simu::nb_steps && !stop_eval; ++i)
				{	    
					// Number of steps the robots are evaluated
					_nb_eval = i + 1;
			
					// We compute the robots' actions in an ever-changing order
		     	std::vector<size_t> ord_vect;
		     	misc::rand_ind(ord_vect, simu.robots().size());
		     	
		     	float fitness = 0;
		     	for(int k = 0; k < ord_vect.size(); ++k)
		     	{
		    		int num = (int)(ord_vect[k]);
		    		assert(num < simu.robots().size());
		    		
		    		StagHuntRobot* robot = (StagHuntRobot*)(simu.robots()[num]);
		    		update_simu(simu);
		    		
		    		std::vector<float> action = robot->step_action();
						
		    		// We compute the movement of the robot
		    		if(action[0] >= 0 || action[1] >= 0)
		    		{
							float v1 = 4.0*(action[0] * 2.0-1.0);
							float v2 = 4.0*(action[1] * 2.0-1.0);
							simu.move_robot(v1, v2, num);

							// We compute the information of movement
							float vt = (fabs(v1) + fabs(v2))/(2.0*4.0);
							float vr = sqrt(fabs(v1 - v2))/sqrt(2.0*4.0);
							float sens_max = robot->sens_max();
							
							if(num == 0)
								fit_mov1 += vt*(1-vr)*(1-sens_max);
							else if(num == 1)
								fit_mov2 += vt*(1-vr)*(1-sens_max);
						}
		     	}
		     	
		     	// And then we update their status : food gathered, prey dead
		     	// For each prey, we check if there are hunters close
		     	std::vector<int> dead_preys;
		     	for(int k = 2; k < simu.robots().size(); ++k)
		     		check_status(simu, (Prey*)(simu.robots()[k]), dead_preys, k);
		     	
		     	// We remove the dead preys
		     	while(!dead_preys.empty())
		     	{
		     		int index = dead_preys.back();
		     		
		     		// Il y a un cas particulier : on veut que les lapins
		     		// reviennent à chacune de leur mort
		     		if(simu.robots()[index]->color() == HARE_COLOR)
		     		{
		     			Posture pos;
							
							if(simu.get_random_initial_position(Params::simu::hare_radius, pos))
							{
								Hare* r = new Hare(Params::simu::hare_radius, pos, HARE_COLOR);
				
								simu.add_robot(r);
							}
		     		}
		     		else if(simu.robots()[index]->color() == BIG_STAG_COLOR)
		     		{
							Posture pos;
				
							if(simu.get_random_initial_position(Params::simu::nb_big_stags, pos))
							{
								// The fur color is randomize between 0 and 1
								int fur_color = misc::rand(100, 200);
					
								Stag* r = new Stag(Params::simu::big_stag_radius, pos, BIG_STAG_COLOR, Stag::big, fur_color);
//								Stag* r = new Stag(Params::simu::big_stag_radius, pos, BIG_STAG_COLOR, Stag::big);
				
								simu.add_robot(r);
							}		     
				 		}
			
		     		dead_preys.pop_back();
		     		simu.remove_robot(index);
		     	}
       	}
       	
       	Hunter* h1 = (Hunter*)(simu.robots()[0]);
       	Hunter* h2 = (Hunter*)(simu.robots()[1]);
       	food1 += h1->get_food_gathered();
       	food2 += h2->get_food_gathered();
       	
       	moy_hares1 += h1->nb_hares_hunted();
       	moy_sstags1 += h1->nb_small_stags_hunted();
       	moy_bstags1 += h1->nb_big_stags_hunted();
        moy_hares1_solo += h1->nb_hares_hunted_solo();
       	moy_sstags1_solo += h1->nb_small_stags_hunted_solo();
       	moy_bstags1_solo += h1->nb_big_stags_hunted_solo();
       	moy_hares2 += h2->nb_hares_hunted();
       	moy_sstags2 += h2->nb_small_stags_hunted();
       	moy_bstags2 += h2->nb_big_stags_hunted();
        moy_hares2_solo += h2->nb_hares_hunted_solo();
       	moy_sstags2_solo += h2->nb_small_stags_hunted_solo();
       	moy_bstags2_solo += h2->nb_big_stags_hunted_solo();
			}

			
			// Mean on all the trials
     	moy_hares1 /= Params::simu::nb_trials;
     	moy_sstags1 /= Params::simu::nb_trials;
     	moy_bstags1 /= Params::simu::nb_trials;
      moy_hares1_solo /= Params::simu::nb_trials;
     	moy_sstags1_solo /= Params::simu::nb_trials;
     	moy_bstags1_solo /= Params::simu::nb_trials;
     	moy_hares2 /= Params::simu::nb_trials;
     	moy_sstags2 /= Params::simu::nb_trials;
     	moy_bstags2 /= Params::simu::nb_trials;
      moy_hares2_solo /= Params::simu::nb_trials;
     	moy_sstags2_solo /= Params::simu::nb_trials;
     	moy_bstags2_solo /= Params::simu::nb_trials;
     	
     	// Mean on all the encouters
     	int nb_encounters = Params::pop::size - 1;
     	moy_hares1 /= nb_encounters;
     	moy_sstags1 /= nb_encounters;
     	moy_bstags1 /= nb_encounters;
      moy_hares1_solo /= nb_encounters;
     	moy_sstags1_solo /= nb_encounters;
     	moy_bstags1_solo /= nb_encounters;
     	moy_hares2 /= nb_encounters;
     	moy_sstags2 /= nb_encounters;
     	moy_bstags2 /= nb_encounters;
      moy_hares2_solo /= nb_encounters;
     	moy_sstags2_solo /= nb_encounters;
     	moy_bstags2_solo /= nb_encounters;

#ifndef PARALLEL     	
     	ind1.set_nb_hares(ind1.nb_hares() + moy_hares1, ind1.nb_hares_solo() + moy_hares1_solo);
     	ind1.set_nb_sstag(ind1.nb_sstag() + moy_sstags1, ind1.nb_sstag_solo() + moy_sstags1_solo);
     	ind1.set_nb_bstag(ind1.nb_bstag() + moy_bstags1, ind1.nb_bstag_solo() + moy_bstags1_solo);
     	ind2.set_nb_hares(ind2.nb_hares() + moy_hares2, ind2.nb_hares_solo() + moy_hares2_solo);
     	ind2.set_nb_sstag(ind2.nb_sstag() + moy_sstags2, ind2.nb_sstag_solo() + moy_sstags2_solo);
     	ind2.set_nb_bstag(ind2.nb_bstag() + moy_bstags2, ind2.nb_bstag_solo() + moy_bstags2_solo);
#else
			ind1.add_nb_hares(moy_hares1, moy_hares1_solo);
			ind1.add_nb_sstag(moy_sstags1, moy_sstags1_solo);
			ind1.add_nb_bstag(moy_bstags1, moy_bstags1_solo);
			ind2.add_nb_hares(moy_hares2, moy_hares2_solo);
			ind2.add_nb_sstag(moy_sstags2, moy_sstags2_solo);
			ind2.add_nb_bstag(moy_bstags2, moy_bstags2_solo);
#endif
     	
     	// And the same for the fit_mov
     	fit_mov1 /= Params::simu::nb_trials;
     	fit_mov2 /= Params::simu::nb_trials;
     	
     	fit_mov1 /= nb_encounters;
     	fit_mov2 /= nb_encounters;
     	
     	ind1.set_fit_mov(ind1.fit_mov() + fit_mov1);
     	ind2.set_fit_mov(ind2.fit_mov() + fit_mov2);

			food1 /= Params::simu::nb_trials;
			food2 /= Params::simu::nb_trials;

			food1 /= nb_encounters;
			food2 /= nb_encounters;

#ifndef PARALLEL
#ifdef MULTI
			ind1.fit().set_obj(0, ind1.fit().obj(0) + food1);
			ind2.fit().set_obj(0, ind2.fit().obj(0) + food2);
#else
			ind1.fit().set_value(ind1.fit().value() + food1);
			ind2.fit().set_value(ind2.fit().value() + food2);
#endif
#else
			ind1.fit().add_fitness(food1);
			ind2.fit().add_fitness(food2);
#endif
#endif
    } // *** end of eval ***

    
    template<typename Simu>
      void init_simu(Simu& simu, nn_t &nn1, nn_t &nn2)
    {
  		// Preparing the environment
      prepare_env(simu, nn1, nn2);
      
      // Visualisation mode
			if(this->mode() == fit::mode::view)
			  simu.init_view(true);      
      
      stop_eval = false;
    }

    // Prepare environment
    template<typename Simu>
      void prepare_env(Simu& simu, nn_t &nn1, nn_t &nn2)
    {
      using namespace fastsim;

      simu.init();
      simu.map()->clear_illuminated_switches();
      
      // *** Preparing the environment ***
	    //Sizes
      width=simu.map()->get_real_w();
      height=simu.map()->get_real_h();
      
      nb_small_stags = 0;
      nb_big_stags = 0;

			// Robots :
			// First the robots for the two hunters
			std::vector<Posture> pos_init;
			pos_init.push_back(Posture(width/2, 80, M_PI/2));
			pos_init.push_back(Posture(width/2, height - 80, -M_PI/2));
			bool invers_pos = misc::flip_coin();
			for(int i = 0; i < 2; ++i)
			{
				Hunter* r;				
				Posture pos = (invers_pos) ? pos_init[(i + 1)%2] : pos_init[i];
				if(i == 0)
					r = new Hunter(Params::simu::hunter_radius, pos, HUNTER_COLOR, nn1);
				else
					r = new Hunter(Params::simu::hunter_radius, pos, HUNTER_COLOR, nn2);
			
				// 6 lasers range sensors 
				r->add_laser(Laser(M_PI / 3, 50));
				r->add_laser(Laser(0, 50));
				r->add_laser(Laser(-M_PI / 3, 50));
				r->add_laser(Laser(2 * M_PI / 3, 50));
				r->add_laser(Laser(M_PI, 50));
				r->add_laser(Laser(-2 * M_PI / 3, 50));
				
				// 1 linear camera
//				r->use_camera();
				r->use_camera(LinearCamera(M_PI/2, Params::simu::nb_camera_pixels));
				
				simu.add_robot(r);
			}
			
			// Then the hares
			for(int i = 0; i < Params::simu::nb_hares; ++i)
			{
				Posture pos;
				
				if(simu.get_random_initial_position(Params::simu::hare_radius, pos))
				{
					Hare* r = new Hare(Params::simu::hare_radius, pos, HARE_COLOR);
			
					// 6 lasers range sensors 
/*					r->add_laser(Laser(M_PI / 3, 50));
					r->add_laser(Laser(0, 50));
					r->add_laser(Laser(-M_PI / 3, 50));
					r->add_laser(Laser(2 * M_PI / 3, 50));
					r->add_laser(Laser(M_PI, 50));
					r->add_laser(Laser(-2 * M_PI / 3, 50));
				
					// 1 linear camera
					r->use_camera();*/
				
					simu.add_robot(r);
				}
			}
			
			// And finally the big stags
			for(int i = 0; i < Params::simu::nb_big_stags; ++i)
			{
				Posture pos;
				
				if(simu.get_random_initial_position(Params::simu::nb_big_stags, pos))
				{
					// The fur color is randomize between 0 and 1
#ifndef RESPECT_PARITY
					int fur_color = misc::rand(100, 200);
					
					Stag* r = new Stag(Params::simu::big_stag_radius, pos, BIG_STAG_COLOR, Stag::big, fur_color);
			
					// 6 lasers range sensors 
/*					r->add_laser(Laser(M_PI / 3, 50));
					r->add_laser(Laser(0, 50));
					r->add_laser(Laser(-M_PI / 3, 50));
					r->add_laser(Laser(2 * M_PI / 3, 50));
					r->add_laser(Laser(M_PI, 50));
					r->add_laser(Laser(-2 * M_PI / 3, 50));
				
					// 1 linear camera
					r->use_camera();*/
				
					simu.add_robot(r);
#else
					int fur_color = misc::rand(100, 200);
					
					Stag* r = new Stag(Params::simu::big_stag_radius, pos, BIG_STAG_COLOR, Stag::big, fur_color);
				
					simu.add_robot(r);
#endif
				}
			}		
		}
    
    // *** Refresh infos about the robots
    template<typename Simu>
      void update_simu(Simu &simu) 
    {
      // refresh
      using namespace fastsim;
//      simu.refresh();
			
			if (this->mode() == fit::mode::view)
			  simu.refresh_view();
    }
    
    template<typename Simu>
    	void check_status(Simu &simu, Prey* prey, std::vector<int>& dead_preys, int position)
   	{
   		using namespace fastsim;
   		
   		// We compute the distance between this prey and each of its hunters
   		std::vector<Hunter*> hunters;
   		float px = prey->get_pos().x();
   		float py = prey->get_pos().y();
   		for(int i = 0; i < 2; ++i)
   		{
   			Hunter* hunter = (Hunter*)(simu.robots()[i]);
   			float hx = hunter->get_pos().x();
   			float hy = hunter->get_pos().y();
   			float dist = sqrt(pow(px - hx, 2) + pow(py - hy, 2));
   			
   			// The radius must not be taken into account
   			if((dist - prey->get_radius() - hunter->get_radius()) <= CATCHING_DISTANCE)
   				hunters.push_back(hunter);
   		}
   		
   		// We check if the prey is blocked
   		prey->blocked_by_hunters(hunters.size());
   		
   		// And then we check if the prey is dead and let the hunters
   		// have a glorious feast on its corpse. Yay !
   		if(prey->is_dead())
   		{
   			float food = 0;
   			
   			if(hunters.size() > 0)
	   			food = prey->feast()/hunters.size();
	   		
   			Prey::type_prey type = prey->get_type();
   			dead_preys.push_back(position);
   			
   			for(int i = 0; i < hunters.size(); ++i)
   			{
   				hunters[i]->add_food(food);
   				
   				if(type == Prey::HARE)
   					hunters[i]->eat_hare(hunters.size() == 1);
   				else if(type == Prey::SMALL_STAG)
   					hunters[i]->eat_small_stag(hunters.size() == 1);
   				else
   					hunters[i]->eat_big_stag(hunters.size() == 1);
   			}
   		}
   	}
   	    
		
    float width, height;
    bool stop_eval;                                  // Stops the evaluation
    int _nb_eval;                                    // Number of evaluation (until the robot stands still)
//    std::vector<nn_t> vec_nn;

		int nb_small_stags, nb_big_stags;
		int max_small_stags, max_big_stags;

		std::vector<float> vec_fitness;
		tbb::atomic<float> fitness_at;
		
		void add_fitness(float fitness)
		{
			fitness_at.fetch_and_store(fitness_at + fitness);
		}
  };
}


// ****************** Main *************************
int main(int argc, char **argv)
{
  srand(time(0));
  
  // FITNESS
  typedef FitStagHunt<Params> fit_t;

	// GENOTYPE
#ifdef MLP  
#ifdef CMAES
  typedef gen::Cmaes<(Params::nn::nb_inputs + 1) * Params::nn::nb_hidden + Params::nn::nb_outputs * Params::nn::nb_hidden + Params::nn::nb_outputs, Params> gen_t;
#else
  typedef gen::EvoFloat<(Params::nn::nb_inputs + 1) * Params::nn::nb_hidden + Params::nn::nb_outputs * Params::nn::nb_hidden + Params::nn::nb_outputs, Params> gen_t;
#endif
#else
#ifdef CMAES
  typedef gen::Cmaes<(Params::nn::nb_inputs + 1) * Params::nn::nb_outputs, Params> gen_t;
#else
  typedef gen::EvoFloat<(Params::nn::nb_inputs + 1) * Params::nn::nb_outputs, Params> gen_t;
#endif
#endif
  
  // PHENOTYPE
  typedef phen::PhenChasseur<gen_t, fit_t, Params> phen_t;

	// EVALUATION
#ifdef PARALLEL
//  typedef eval::Parallel<Params> eval_t;
	typedef eval::StagHuntEvalParallel<Params> eval_t;
#else
  typedef eval::StagHuntEval<Params> eval_t;
#endif

  // STATS 
  typedef boost::fusion::vector<
		  sferes::stat::BestFitEval<phen_t, Params>,
		  sferes::stat::MeanFitEval<phen_t, Params>,
		  sferes::stat::BestEverFitEval<phen_t, Params>,
		  sferes::stat::AllFitEvalStat<phen_t, Params>,
		  sferes::stat::StopEval<Params>
    >  stat_t;
  
  //MODIFIER
  typedef modif::Dummy<Params> modifier_t;

	// EVOLUTION ALGORITHM
#ifdef FITPROP
  typedef ea::FitnessProp<phen_t, eval_t, stat_t, modifier_t, Params> ea_t; 
#else
#ifdef MULTI
  typedef ea::Nsga2<phen_t, eval_t, stat_t, modifier_t, Params> ea_t; 
#else
#ifdef CMAES
  typedef ea::Cmaes<phen_t, eval_t, stat_t, modifier_t, Params> ea_t;
#else
  typedef ea::RankSimple<phen_t, eval_t, stat_t, modifier_t, Params> ea_t;
#endif
#endif
#endif

  ea_t ea;

  // RUN EA
  time_t exec = time(NULL);
  run_ea(argc, argv, ea);
	std::cout << "Temps d'exécution : " << time(NULL) - exec;

  return 0;
}
