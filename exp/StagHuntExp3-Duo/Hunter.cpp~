#include "Hunter.hpp"

void Hunter::step_action(fastsim::FastsimMulti& simu, int robot_index)
{
  using namespace fastsim;

	_nn.init();

	std::vector<float> inputs;
	inputs.resize(Params::nn:nb_inputs);
	
	// We compute the inputs of the nn  
  // Update of the sensors
  size_t nb_lasers = this->get_lasers().size();

  // *** set inputs ***
  std::vector<float> dlasers;
  
  for (size_t j = 0; j < nb_lasers; ++j)
	{
		float d = this->get_lasers()[j].get_dist();
		dlasers.push_back(d);
		float range = this->get_lasers()[j].get_range();

		inputs[j] = (d == -1 ? 0 : 1 - d / range);
	}

  inputs[nb_lasers+0] = this->get_left_bumper() ? 1 : 0;
  inputs[nb_lasers+1] = this->get_right_bumper() ? 1 : 0;
  
  // Inputs for the camera
  for(int i = 0; i < Params::simu::nb_camera_pixels; ++i)
  {
  	assert(nb_lasers + 2 + i < inputs.size());
  	assert(i < this->get_camera().pixels().size());
  	inputs[nb_lasers + 2 + i] = this->get_camera().pixels()[i];
  }

#ifndef MLP 		
	// Bias neuron
	inputs[nb_lasers + 2 + Params::simu::nb_camera_pixels] = 1.0;
#endif

	// Step check of the inputs
  _nn.step(inputs);
  const std::vector<float>& outf = _nn.get_outf();
  assert(outf.size() == 2);

  for(size_t j = 0; j < outf.size(); j++)
		if(isnan(outf[j]))
			outf[j] = 0.0;
			
	// And finally the robot's movement
  float v1 = 4.0*(outf[0] * 2.0-1.0);
  float v2 = 4.0*(outf[1] * 2.0-1.0);
  simu.move_robot(v1, v2, robot_index);
}
